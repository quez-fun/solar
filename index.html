<!DOCTYPE html>
<html>

  <head>
    <title>View Solar</title>
    <meta charset="utf-8">
    <meta name="viewport"
      content="width=device-width, height=device-height, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel='stylesheet' href='./style.css'>
  </head>

  <body>

    <canvas id="canvas"></canvas>


    <script id="vertex-shader-3d" type="x-shader/x-vertex">
      uniform mat4 u_worldViewProjection;
      attribute vec4 a_position;

      void main() {
        gl_Position = u_worldViewProjection * a_position;
      }
    </script>
    <script id="fragment-shader-3d" type="x-shader/x-fragment">
        precision highp float;

        void main() {
          gl_FragColor = vec4(0.65, 0.6, 0.5, 1.0);
        }
  </script>
    <script id="pick-vertex-shader-3d" type="x-shader/x-vertex">
    uniform mat4 u_worldViewProjection;
    
    attribute vec4 a_position;
    
    void main() {
      gl_Position = u_worldViewProjection * a_position;
    }
</script>
    <script id="pick-fragment-shader-3d" type="x-shader/x-fragment">

    precision mediump float;
    
    uniform vec4 u_id;
    
    void main() {
      //gl_FragColor = u_id;
      gl_FragColor = vec4(1.0, 0.8, 0.0, 1.0);
    }

</script>

    <script src="./webgl-utils.js"></script>
    <script src="./m4.js"></script>

    <script>

      "use strict";

      const width = 13.4, height = 4.2; //single tile dimension
      const rowNum = 6, columnNum = 7; //roof pieces
      let tileRow = 5, tileColumn = 6, maxTileColumn = 6; //tile pieces
      let gapW = 0.2, gapH = 0.2;

      let tiles = [];

      //gl init
      const canvas = document.getElementById("canvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        //return;
      }

      let aspect = canvas.clientWidth / canvas.clientHeight;


      //创建frame buffer
      const targetTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, targetTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);


      const depthBuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);

      function setFramebufferAttachmentSizes(width, height) {
        gl.bindTexture(gl.TEXTURE_2D, targetTexture);
        const level = 0;
        const internalFormat = gl.RGBA;
        const border = 0;
        const format = gl.RGBA;
        const type = gl.UNSIGNED_BYTE;
        const data = null;
        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
          width, height, border,
          format, type, data);

        //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.width * 2, gl.canvas.height * 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
      }
      setFramebufferAttachmentSizes(1, 1); //从draw循环提到这里没用
      /**/
      const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb); //这条放出来以后，图形就没了，但也分离了渲染层和pick层
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);


      let pickUniforms = {
        u_worldViewProjection: m4.identity(),
        u_world: m4.identity(),
      };

      //projection & view
      const fieldOfViewRadians = degToRad(60);
      const up = [0, 1, 0];
      let cameraPosition = [100, 0, 100/*180, -10, 60*/], targetPosition = [0, 0, 0];

      const radius = Math.sqrt(180 * 180 + 10 * 10 + 60 * 60);
      let cameraMatrix = m4.lookAt(cameraPosition, targetPosition, up, m4.identity());
      let viewMatrix = m4.inverse(cameraMatrix);

      const uniformsThatAreComputedForEachtile = {
        u_worldViewProjection: m4.identity(),
      };

      const arrays = {
        position: { numComponents: 3, data: [-width / 2, -height / 2, 0, width / 2, -height / 2, 0, -width / 2, height / 2, 0, width / 2, height / 2, 0], },
        indices: { numComponents: 3, data: [0, 1, 2, 1, 2, 3], },
      };

      const xRot = Math.PI / 3.5;
      const bodyWidth = (width + gapW) * rowNum - 10,
        bodyHeight = 25,
        bodyLength = (height + gapH) * columnNum * Math.sin(xRot) - 2;

      function roofBuffer() {

        for (var i = 0; i < rowNum; i++) {

          for (var j = 0; j < columnNum; j++) {

            tiles.push({

              yRotation: 0,//Math.PI/2,
              xRotation: xRot,
              zRotation: 0,//Math.PI/4,
              xTranslation: - (width + gapW) * (i - rowNum / 2) - width / 2 - gapW / 2,
              yTranslation: (j - columnNum / 2) * (height + gapH) * Math.cos(xRot) + gapH / 2 + bodyHeight / 2,
              zTranslation: (height + gapH) * j * Math.sin(xRot) - (height + gapH) * (columnNum - 0.5) * Math.sin(xRot),

              pickIDUniform: {
                u_id: [3 / 255, 0, 0, 1],
              }

            });

            tiles.push({

              yRotation: 0,//Math.PI/2,
              xRotation: -xRot,
              zRotation: 0,//Math.PI/4,
              xTranslation: - (width + gapW) * (i - rowNum / 2) - width / 2 - gapW / 2,
              yTranslation: (j - columnNum / 2) * (height + gapH) * Math.cos(-xRot) + gapH / 2 + bodyHeight / 2,
              zTranslation: (height + gapH) * j * Math.sin(-xRot) + (height + gapH) * (columnNum - 0.5) * Math.sin(xRot),

              pickIDUniform: {
                u_id: [3 / 255, 0, 0, 1],
              }

            });

          }

        }

      }

      roofBuffer();

      const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, arrays);
      const programInfo = webglUtils.createProgramInfo(gl, ["vertex-shader-3d", "fragment-shader-3d"]);
      const pickProgramInfo = webglUtils.createProgramInfo(gl, ["pick-vertex-shader-3d", "pick-fragment-shader-3d"]);

      function degToRad(d) {
        return d * Math.PI / 180;
      }


      function drawScene(e) {

        resizeCanvasToDisplaySize(canvas);


        {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          gl.clearColor(0.1, 0.1, 0.1, 1.0);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

          var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

          var cameraMatrix = m4.lookAt(cameraPosition, targetPosition, up, m4.identity());
          viewMatrix = m4.inverse(cameraMatrix);

          var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

          gl.useProgram(programInfo.program);
          webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);

          var worldMatrix = m4.xRotation(0);

          m4.multiply(viewProjectionMatrix, worldMatrix, uniformsThatAreComputedForEachtile.u_worldViewProjection);

          webglUtils.setUniforms(programInfo, uniformsThatAreComputedForEachtile);


          tiles.forEach(function (tile) {

            let worldMatrix = m4.xRotation(0);
            worldMatrix = m4.translate(worldMatrix, tile.xTranslation, tile.yTranslation, tile.zTranslation);
            worldMatrix = m4.yRotate(worldMatrix, tile.yRotation);
            worldMatrix = m4.xRotate(worldMatrix, tile.xRotation);
            worldMatrix = m4.zRotate(worldMatrix, tile.zRotation);

            // Multiply the matrices.
            m4.multiply(viewProjectionMatrix, worldMatrix, uniformsThatAreComputedForEachtile.u_worldViewProjection);

            // Set the uniforms we just computed
            webglUtils.setUniforms(programInfo, uniformsThatAreComputedForEachtile);

            // Draw the geometry.
            gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);

          });
        }


        if (e) renderPicking(e);



      }


      /**/
      function renderPicking(e) {

        //resizeCanvasToDisplaySize(canvas);

        setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);

        // 创建mouse event对frustum matrix的转换通讯

        const near = 1, far = 2000;
        const top = Math.tan(degToRad(60) * 0.5) * near;
        const bottom = -top;
        const left = aspect * bottom;
        const right = aspect * top;
        const width = Math.abs(right - left);
        const height = Math.abs(top - bottom);
        const rect = canvas.getBoundingClientRect();

        const pixelX = (e.clientX - rect.left) * gl.canvas.width / gl.canvas.clientWidth;
        const pixelY = gl.canvas.height - (e.clientY - rect.top) * gl.canvas.height / gl.canvas.clientHeight - 1;

        const subLeft = left + pixelX * width / gl.canvas.width;
        const subBottom = bottom + pixelY * height / gl.canvas.height;
        const subWidth = width / gl.canvas.width;
        const subHeight = height / gl.canvas.height;

        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.viewport(0, 0, 1, 1);
        //gl.enable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);

        // Clear the canvas AND the depth buffer.
        //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //去掉这个就没有半截的pixel了

        var projectionMatrix = m4.frustum(subLeft, subLeft + subWidth, subBottom, subBottom + subHeight, near, far);

        var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

        gl.useProgram(pickProgramInfo.program);

        webglUtils.setBuffersAndAttributes(gl, pickProgramInfo, bufferInfo);

        webglUtils.setUniforms(pickProgramInfo, pickUniforms);


        // Draw objects
        tiles.forEach(function (tile) {

          let worldMatrix = m4.xRotation(0);
          worldMatrix = m4.translate(worldMatrix, tile.xTranslation, tile.yTranslation, tile.zTranslation);
          worldMatrix = m4.yRotate(worldMatrix, tile.yRotation);
          worldMatrix = m4.xRotate(worldMatrix, tile.xRotation);
          worldMatrix = m4.zRotate(worldMatrix, tile.zRotation);
          pickUniforms.u_world = worldMatrix;

          // Multiply the matrices.
          m4.multiply(viewProjectionMatrix, worldMatrix, pickUniforms.u_worldViewProjection);

          // Set the uniforms we just computed
          webglUtils.setUniforms(pickProgramInfo, pickUniforms);

          webglUtils.setUniforms(pickProgramInfo, tile.pickIDUniform);

          gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);

        });

        //阅读物体id
        const pixels = new Uint8Array(4);
        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        console.log('pixel is: ' + pixels); //目前读到的是drawscene

      }

      function resizeCanvasToDisplaySize(canvas, multiplier) {
        multiplier = multiplier || 2;
        const width = canvas.clientWidth * multiplier | 0;
        const height = canvas.clientHeight * multiplier | 0;
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
          aspect = width / height;
          return true;
        }
        return false;
      }

      let x1 = 0, x2 = 0, y1 = 0, y2 = 0;

      function onMouseDown(e) {

        //renderPicking(e);

        drawScene(e);

        window.addEventListener('mousemove', onMouseMove, false);

        x1 = e.clientX, y1 = e.clientY;

      }

      let rad = 0;
      function onMouseMove(e) {
        //renderPicking(e);
        x2 = e.clientX, y2 = e.clientY;

        rad -= (x2 - x1) / 50;

        cameraPosition[0] = radius * Math.cos(rad);
        cameraPosition[2] = radius * Math.sin(rad);

        //cameraPosition[1] += y2-y1;
        //console.log(cameraPosition[1]); 

        var cameraMatrix = m4.lookAt(cameraPosition, targetPosition, up, m4.identity());
        viewMatrix = m4.inverse(cameraMatrix);

        drawScene(e);
        x1 = x2;
        y1 = y2;
      }

      function onMouseUp() {
        x1 = 0;
        x2 = 0;
        y1 = 0;
        y2 = 0;
        //isMouseDown = false;
        window.removeEventListener('mousemove', onMouseMove, false);
      }

      window.addEventListener('mousedown', onMouseDown, false);
      window.addEventListener('mouseup', onMouseUp, false);

      drawScene();

      window.addEventListener('resize', drawScene, false);

      //canvas.addEventListener('mousemove', renderPicking, false);

    </script>


  </body>

</html>
